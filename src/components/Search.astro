---
import { Search as SearchIcon, X } from '@lucide/astro';
// Search component for site-wide search functionality
---

<div class="relative" id="search-container">
  <button
    id="search-toggle"
    class="p-3 rounded-full border border-white/25 text-white hover:bg-white/10 transition-colors min-w-[44px] min-h-[44px] flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:ring-offset-2 focus:ring-offset-emerald-950"
    aria-label="Search (Press Ctrl+K)"
    title="Search (Ctrl+K)"
  >
    <SearchIcon class="w-5 h-5" aria-hidden="true" />
  </button>

  <!-- Search Overlay -->
  <div
    id="search-overlay"
    class="fixed inset-0 bg-black bg-opacity-40 z-50 hidden"
    role="dialog"
    aria-modal="true"
    aria-label="Site search"
  >
    <div class="flex items-start justify-center min-h-screen pt-16">
      <div class="bg-white rounded-2xl shadow-2xl shadow-emerald-900/10 w-full max-w-2xl mx-4 border border-emerald-900/10">
        <div class="p-6">
          <div class="relative mb-4">
            <input
              type="text"
              id="search-input"
              placeholder="Search articles, services and conditions..."
              class="w-full px-4 py-3 pl-10 pr-12 rounded-lg border border-emerald-900/20 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent bg-white"
              autocomplete="off"
              aria-describedby="search-help"
            >
            <SearchIcon class="w-5 h-5 text-gray-400 absolute left-3 top-3.5" aria-hidden="true" />
            <button
              id="search-close"
              class="absolute right-2 top-2 text-gray-400 hover:text-emerald-700 p-1.5 rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500"
              aria-label="Close search"
            >
              <X class="w-5 h-5" aria-hidden="true" />
            </button>
          </div>

          <!-- Search Results -->
          <div
            id="search-results"
            class="max-h-96 overflow-y-auto"
            role="region"
            aria-live="polite"
            aria-atomic="false"
          ></div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  /* :global() required — these elements are injected via innerHTML at runtime
     and don't receive Astro's scoped component attribute */
  :global(.search-result-link) {
    @apply block px-3 py-5 border-b border-gray-200 hover:bg-emerald-50/60 transition-colors focus:outline-none focus:bg-emerald-100 focus:ring-2 focus:ring-inset focus:ring-emerald-500;
  }

  :global(.search-result-link:last-child) {
    @apply border-b-0;
  }
</style>

<script>
  import Fuse from 'fuse.js';

  class SiteSearch {
    fuse: any = null;
    searchData: any[] = [];
    selectedIndex: number = -1;
    resultLinks: HTMLElement[] = [];
    abortController: AbortController = new AbortController();

    constructor() {
      this.init();
    }

    destroy() {
      // Cancels all event listeners attached with { signal } so they don't stack
      // across View Transition navigations.
      this.abortController.abort();
    }

    async init() {
      await this.loadSearchData();
      this.setupEventListeners();
    }

    async loadSearchData() {
      try {
        const response = await fetch('/api/search-data.json');
        if (response.ok) {
          const data = await response.json();
          this.searchData = [
            ...(data.articles || []),
            ...(data.services || []),
            ...(data.conditions || [])
          ];
        } else {
          console.warn('Could not load search data from API');
          this.searchData = [];
        }

        this.fuse = new Fuse(this.searchData, {
          keys: ['title', 'description', 'category'],
          threshold: 0.3,
          includeScore: true
        });
      } catch (error) {
        console.error('Error loading search data:', error);
        this.searchData = [];
      }
    }

    setupEventListeners() {
      const signal = this.abortController.signal;
      const searchToggle = document.getElementById('search-toggle');
      const searchOverlay = document.getElementById('search-overlay');
      const searchClose = document.getElementById('search-close');
      const searchInput = document.getElementById('search-input') as HTMLInputElement | null;

      const openSearch = () => {
        searchOverlay?.classList.remove('hidden');
        searchInput?.focus();
        document.body.style.overflow = 'hidden';
      };

      const closeSearch = () => {
        searchOverlay?.classList.add('hidden');
        if (searchInput) searchInput.value = '';
        this.clearResults();
        this.selectedIndex = -1;
        document.body.style.overflow = '';
        searchToggle?.focus();
      };

      searchToggle?.addEventListener('click', openSearch, { signal });
      searchClose?.addEventListener('click', closeSearch, { signal });

      searchOverlay?.addEventListener('click', (e) => {
        if (e.target === searchOverlay) closeSearch();
      }, { signal });

      searchOverlay?.addEventListener('keydown', (e) => {
        if (e.key !== 'Tab') return;
        const focusable = searchOverlay.querySelectorAll<HTMLElement>(
          'button, input, a[href], [tabindex]:not([tabindex="-1"])'
        );
        if (focusable.length === 0) return;
        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault();
          last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }, { signal });

      // Keyboard shortcuts (Ctrl+K / Cmd+K and Escape) — on document,
      // so they must be cleaned up via signal to avoid stacking.
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
          e.preventDefault();
          searchOverlay?.classList.contains('hidden') ? openSearch() : closeSearch();
        }
        if (e.key === 'Escape' && !searchOverlay?.classList.contains('hidden')) {
          closeSearch();
        }
      }, { signal });

      searchInput?.addEventListener('input', (e) => {
        this.selectedIndex = -1;
        this.performSearch((e.target as HTMLInputElement).value);
      }, { signal });

      searchInput?.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          this.navigateResults(1);
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          this.navigateResults(-1);
        } else if (e.key === 'Enter' && this.selectedIndex >= 0) {
          e.preventDefault();
          this.resultLinks[this.selectedIndex]?.click();
        }
      }, { signal });

    }

    navigateResults(direction: number) {
      this.resultLinks = Array.from(document.querySelectorAll('.search-result-link'));
      if (this.resultLinks.length === 0) return;

      // Remove highlight from current
      if (this.selectedIndex >= 0 && this.resultLinks[this.selectedIndex]) {
        this.resultLinks[this.selectedIndex].classList.remove('bg-emerald-100');
      }

      // Calculate new index
      this.selectedIndex += direction;
      if (this.selectedIndex < 0) this.selectedIndex = this.resultLinks.length - 1;
      if (this.selectedIndex >= this.resultLinks.length) this.selectedIndex = 0;

      // Highlight and scroll to new selection
      const selected = this.resultLinks[this.selectedIndex];
      if (selected) {
        selected.classList.add('bg-emerald-100');
        selected.scrollIntoView({ block: 'nearest' });
        selected.focus();
      }
    }

    performSearch(query: string) {
      const resultsContainer = document.getElementById('search-results');

      if (!query.trim()) {
        this.clearResults();
        return;
      }

      if (!this.fuse) {
        if (resultsContainer) {
          resultsContainer.innerHTML = '<p class="text-red-500 text-center py-4">Search not available</p>';
        }
        return;
      }

      const results = this.fuse.search(query);
      this.displayResults(results, query);
    }

    displayResults(results: any[], query: string) {
      const resultsContainer = document.getElementById('search-results');
      if (!resultsContainer) return;

      if (results.length === 0) {
        resultsContainer.innerHTML = `
          <p class="text-gray-500 text-center py-8">
            No results found for "${this.escapeHtml(query)}"
          </p>
        `;
        return;
      }

      const resultsHTML = results.slice(0, 10).map((result) => {
        const item = result.item;

        return `
          <a href="${this.escapeHtml(item.url)}" class="search-result-link" tabindex="0">
            <div class="flex items-center justify-between gap-3">
              <div class="flex-1 min-w-0">
                <h4 class="font-semibold text-gray-900 mb-1.5">${this.escapeHtml(item.title)}</h4>
                <p class="text-sm text-gray-400 line-clamp-1">${this.escapeHtml(item.description)}</p>
              </div>
              <svg class="w-4 h-4 text-gray-300 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
              </svg>
            </div>
          </a>
        `;
      }).join('');

      resultsContainer.innerHTML = `
        <p class="sr-only">${results.length} results found</p>
        ${resultsHTML}
      `;

      this.resultLinks = Array.from(document.querySelectorAll('.search-result-link'));
    }

    escapeHtml(text: string): string {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    clearResults() {
      const resultsContainer = document.getElementById('search-results');
      if (resultsContainer) resultsContainer.innerHTML = '';
      this.resultLinks = [];
    }
  }

  // Always reinitialize on each navigation — destroy old listeners via AbortController
  // before creating a new instance so document-level handlers don't stack.
  let searchInstance: SiteSearch | null = null;
  function initSearch() {
    searchInstance?.destroy();
    searchInstance = new SiteSearch();
  }
  initSearch();
  document.addEventListener('astro:page-load', initSearch);
</script>
